echo "Распределение продолжительности соединений с течением времени."
echo "Отбирается событие завершения соединения (вся длимтельность соединения фиксируется на его завершении)"
time grep -r ".*" -H /c/1c_logs/logs/*/*.log  | \
perl -ne '
    use 5;
    s/\xef\xbb\xbf//;                               #BOM - обязательно в начале, иначе с певой строкой будут проблемы
    if(/log:\d\d:\d\d\.\d+-\d+,(\w+),/){            #если в строке есть идентификатор начала строки и это наш тип события
        if(/CONN/){                                 #первоначальный отбор по событиям            
            s/\s+/ /g;                              #сворачиваю много пробелов в один, и перенос строки тоже здесь улетит в пробел
            if(s/^.*_(\d+)\/(\d{2})(\d{2})(\d{2})(\d{2})\.log\:\s*(\d+:\d+\.\d+)\-(\d+),(\w+),(\d+)//){
                $_="\r\n"."dt=20".$2.".".$3.".".$4.",time=".$5.":".$6.",pid=".$1.",dur=".$7.",evnt=".$8.",ukn=".$9.$_ ;                
            }
            $f=1;
        }else{$f=0};
    }
    elsif($f) {                                     #если наше событие, то обрабатываем эту висячую  строку
        s/^.*log://;                                #из перенесённых строк просто вытираю начало
        s/\s+/ /g;                                  #сворачиваю много пробелов в один, и перенос строки тоже здесь улетит в пробел
    }
    if($f){
        s/\x27//g;                                  #убираю апострофы
        print;
    }END{print "\r\n"}                              #надо поставить, чтобы последняя строка в обработку попала
' | \perl -ne '                                      #perl умеет работать как AWK
    use 5;
    if(/dt=(\d+.\d+\.\d+).*time=(\d+\:\d+).*dur=(\d+),evnt=CONN,.*Txt=.*connection\sclosed/){
        $dur_ttl+=$2/1000;
        $dur{$1." ".$2}+=$3/1000;
        $cnt_ttl+=1;
        $cnt{$1." ".$2}+=1;
        #print $_."\r\n";
    }
    END{
        printf("=====TIME TOTAL(ms):%.2f      COUNT:%d      AVG(ms):%.2f\r\n",
               $dur_ttl,
               $cnt_ttl,
               $dur_ttl/$cnt_ttl);              #формирую заголовок
        foreach $k (sort {$cnt{$b} <=> $cnt{$a}} keys %cnt) {
            last if ($_+=1)>50;                 #но только первые 10 строк
            printf "$_: [][][] TIME(ms):%d [][][] TIME(%):%.2f [][][] COUNT:%d [][][] COUNT(%):%.2f [][][] AVG(ms):%d [][][] BY:%s \r\n",
            $dur{$k},
            $dur{$k}/$dur_ttl*100,
            $cnt{$k},
            $cnt{$k}/$cnt_ttl*100,
            $dur{$k}/$cnt{$k},
            $k;                                 #сортирую массив по убыванию длительности и вывожу его
        }
    }'